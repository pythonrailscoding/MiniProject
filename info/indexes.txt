"""
============================================================================================================
                            COMPLETE GUIDE TO MONGODB INDEXES
============================================================================================================

WHAT ARE INDEXES?
-----------------
Think of indexes like the index at the back of a textbook. Instead of reading every page to find
"Chapter 5", you look at the index which tells you exactly which page to go to.

In databases, indexes make queries MUCH FASTER by creating a sorted "lookup table" for specific fields.

Without Index (Full Collection Scan):
    - MongoDB reads EVERY document in the collection to find what you want
    - If you have 100,000 tasks, it checks all 100,000 documents
    - Time complexity: O(n) - linear time, gets slower as data grows

With Index:
    - MongoDB jumps directly to the right document(s)
    - Uses a tree structure (B-tree) to find data in logarithmic time
    - If you have 100,000 tasks, it might only check ~20 documents
    - Time complexity: O(log n) - logarithmic time, stays fast even with massive data


PERFORMANCE COMPARISON:
-----------------------
Without indexes:
    - 1,000 tasks → ~50ms query time
    - 100,000 tasks → ~5000ms (5 seconds!) query time 😱
    - 1,000,000 tasks → ~50,000ms (50 seconds!) query time 💀

With indexes:
    - 1,000 tasks → ~2ms query time
    - 100,000 tasks → ~5ms query time ⚡
    - 1,000,000 tasks → ~10ms query time ⚡⚡


HOW INDEXES WORK INTERNALLY:
-----------------------------
When you create an index, MongoDB creates a SEPARATE DATA STRUCTURE (not in your main collection)
that stores:
    1. The indexed field value(s)
    2. A pointer (reference) to the actual document

Example:
Your tasks collection (unordered, stored as inserted):
    {_id: 1, user_id: ObjectId('abc'), title: 'Task 1', created_at: Oct 14}
    {_id: 2, user_id: ObjectId('xyz'), title: 'Task 2', created_at: Oct 16}
    {_id: 3, user_id: ObjectId('abc'), title: 'Task 3', created_at: Oct 16}
    {_id: 4, user_id: ObjectId('abc'), title: 'Task 4', created_at: Oct 15}

MongoDB's index structure (stored separately, in B-tree format):
    ┌─────────────┬─────────────┬─────────────┐
    │ user_id     │ created_at  │ points to   │
    ├─────────────┼─────────────┼─────────────┤
    │ abc         │ Oct 16      │ doc _id: 3  │ ← Most recent for 'abc'
    │ abc         │ Oct 15      │ doc _id: 4  │
    │ abc         │ Oct 14      │ doc _id: 1  │ ← Oldest for 'abc'
    │ xyz         │ Oct 16      │ doc _id: 2  │
    └─────────────┴─────────────┴─────────────┘

This index is PHYSICALLY STORED in this sorted order on disk.


============================================================================================================
                            UNDERSTANDING INDEX SORT ORDER: 1 vs -1
============================================================================================================

WHAT DO 1 AND -1 MEAN?
----------------------
- 1  = Ascending order  (A→Z, 0→9, oldest→newest, small→big)
- -1 = Descending order (Z→A, 9→0, newest→oldest, big→small)

These numbers tell MongoDB HOW TO PHYSICALLY STORE the index data.


EXAMPLE 1: Simple Index with Ascending Order
---------------------------------------------
db.users.create_index('username', 1)  # or just db.users.create_index('username')

MongoDB stores the index like this:
    username (ascending)     points to document
    ─────────────────────    ──────────────────
    @alice                → {_id: ObjectId('001'), username: '@alice'}
    @bob                  → {_id: ObjectId('002'), username: '@bob'}
    @charlie              → {_id: ObjectId('003'), username: '@charlie'}
    @david                → {_id: ObjectId('004'), username: '@david'}

When you query: db.users.find_one({'username': '@charlie'})
MongoDB does a binary search (very fast!) on this sorted list.


EXAMPLE 2: Simple Index with Descending Order
----------------------------------------------
db.tasks.create_index('created_at', -1)

MongoDB stores the index like this:
    created_at (descending)  points to document
    ───────────────────────  ──────────────────
    2025-10-16 10:30:00    → {_id: ObjectId('123'), created_at: ...}  ← Newest
    2025-10-16 09:15:00    → {_id: ObjectId('124'), created_at: ...}
    2025-10-15 14:20:00    → {_id: ObjectId('125'), created_at: ...}
    2025-10-14 08:00:00    → {_id: ObjectId('126'), created_at: ...}  ← Oldest

Perfect for queries like: db.tasks.find().sort('created_at', -1)  # Get newest first
MongoDB can just read the index top-to-bottom without re-sorting!


EXAMPLE 3: Compound Index (Multiple Fields)
--------------------------------------------
db.tasks.create_index([('user_id', 1), ('created_at', -1)])

This creates a COMPOUND index on TWO fields:
    - First sorted by user_id (ascending)
    - Then within each user_id, sorted by created_at (descending)

MongoDB stores it like this:
    ┌─────────────────┬──────────────────┬─────────────┐
    │ user_id (asc)   │ created_at (desc)│ points to   │
    ├─────────────────┼──────────────────┼─────────────┤
    │ ObjectId(abc)   │ 2025-10-16       │ doc _id: 5  │ ← User abc's newest task
    │ ObjectId(abc)   │ 2025-10-15       │ doc _id: 3  │
    │ ObjectId(abc)   │ 2025-10-14       │ doc _id: 1  │ ← User abc's oldest task
    │ ObjectId(def)   │ 2025-10-16       │ doc _id: 8  │ ← User def's newest task
    │ ObjectId(def)   │ 2025-10-13       │ doc _id: 6  │
    │ ObjectId(xyz)   │ 2025-10-17       │ doc _id: 9  │ ← User xyz's newest task
    │ ObjectId(xyz)   │ 2025-10-15       │ doc _id: 4  │
    └─────────────────┴──────────────────┴─────────────┘

Notice how tasks are grouped by user_id, and within each user, sorted by date (newest first).


WHY THIS MATTERS - MATCHING YOUR QUERIES:
------------------------------------------
Your code does this:
    todo_list.sort(key=lambda todo: todo['created_at'], reverse=True)

    reverse=True means DESCENDING order (newest first)

So your index should match:
    db.tasks.create_index([('user_id', 1), ('created_at', -1)])
                                                          ^^^ -1 = descending = newest first

When you query:
    db.tasks.find({'user_id': ObjectId('abc')}).sort('created_at', -1)

MongoDB can:
    1. Jump to user_id = 'abc' in the index
    2. Read documents in order (they're already sorted newest first!)
    3. Return results immediately - NO SORTING NEEDED!


WHAT IF YOU USED THE WRONG ORDER?
----------------------------------
If you created: db.tasks.create_index([('user_id', 1), ('created_at', 1)])
                                                                      ^^^ Wrong! 1 = ascending

Index would store:
    user_id         created_at (ascending - OLDEST first)
    ObjectId(abc) → 2025-10-14  ⬆️ oldest
    ObjectId(abc) → 2025-10-15
    ObjectId(abc) → 2025-10-16  newest

When you query with .sort('created_at', -1):
    - MongoDB would use the index to find user_id = 'abc' ✅
    - But then it would have to REVERSE the order in memory ❌
    - Still faster than no index, but not optimal

BEST PRACTICE: Match your index sort order to your most common query patterns!


============================================================================================================
                            AUTOMATIC INDEX MAINTENANCE
============================================================================================================

DOES MONGODB MAINTAIN THE SORTED ORDER AUTOMATICALLY?
------------------------------------------------------
YES! MongoDB automatically keeps the index sorted when you:
    - INSERT new documents
    - UPDATE indexed fields
    - DELETE documents

Example of automatic maintenance:
----------------------------------
Current index state:
    user_id     created_at      points to
    ────────    ──────────      ─────────
    abc         Oct 16          doc 3
    abc         Oct 15          doc 4
    abc         Oct 14          doc 1

You insert a new task:
    db.tasks.insert_one({
        'user_id': ObjectId('abc'),
        'created_at': datetime(2025, 10, 17),
        'title': 'Newest task'
    })

MongoDB AUTOMATICALLY updates the index:
    user_id     created_at      points to
    ────────    ──────────      ─────────
    abc         Oct 17 ← NEW!   doc 5     ← Inserted at the correct position!
    abc         Oct 16          doc 3
    abc         Oct 15          doc 4
    abc         Oct 14          doc 1

The new document is inserted in the CORRECT SORTED POSITION automatically!


TRADE-OFFS OF INDEXES:
----------------------
Pros:
    ✅ Lightning-fast queries (O(log n) instead of O(n))
    ✅ Automatic sorting for ORDER BY queries
    ✅ Enforces uniqueness (with unique=True)
    ✅ Supports efficient $gt, $lt, $gte, $lte operations

Cons:
    ❌ Takes up disk space (each index is a separate data structure)
    ❌ Slows down INSERT/UPDATE/DELETE operations (index must be updated)
    ❌ Too many indexes can hurt performance more than help

Rule of thumb: Create indexes for fields you query frequently, but don't over-index!


============================================================================================================
                            TYPES OF INDEXES IN YOUR APPLICATION
============================================================================================================

INDEX 1: Username (Unique Index)
---------------------------------
db.users.create_index('username', unique=True)

Purpose:
    - Fast lookup when logging in: db.users.find_one({'username': '@john'})
    - Enforces uniqueness - prevents duplicate usernames at database level
    - Without this, checking for duplicate usernames would require scanning all users!

How it helps:
    - Login queries: O(log n) instead of O(n)
    - 1 million users? Still finds username in ~20 comparisons instead of 1 million!

Physical storage:
    username        points to
    ────────        ─────────
    @alice        → user doc 1
    @bob          → user doc 2
    @charlie      → user doc 3

When you try to insert duplicate:
    db.users.insert_one({'username': '@alice', ...})
    MongoDB ERROR: "duplicate key error" - ENFORCED BY INDEX!


INDEX 2: Compound Index on user_id and created_at
--------------------------------------------------
db.tasks.create_index([('user_id', 1), ('created_at', -1)])

Purpose:
    - Optimized for: "Get all tasks for THIS user, sorted by NEWEST first"
    - This is your most common query pattern in get_tasks()

Queries this index optimizes:
    ✅ db.tasks.find({'user_id': ObjectId('abc')})
    ✅ db.tasks.find({'user_id': ObjectId('abc')}).sort('created_at', -1)
    ✅ db.tasks.count_documents({'user_id': ObjectId('abc')})
    ✅ db.tasks.find({'user_id': ObjectId('abc'), 'completed': True})  # Can use index partially

Index Prefix Rule:
    A compound index can be used for queries on:
        - Just the first field ('user_id')
        - First + second field ('user_id' + 'created_at')
    But NOT:
        - Just the second field ('created_at' alone) ❌

Example:
    ✅ find({'user_id': 'abc'})                              # Uses index
    ✅ find({'user_id': 'abc'}).sort('created_at', -1)       # Uses index perfectly
    ❌ find({}).sort('created_at', -1)                       # Cannot use this index
    ❌ find({'created_at': {'$gt': some_date}})              # Cannot use this index

Physical storage:
    user_id         created_at (desc)   points to
    ───────         ─────────────────   ─────────
    ObjectId(abc)   2025-10-16         → task doc 5  ← abc's newest
    ObjectId(abc)   2025-10-15         → task doc 3
    ObjectId(abc)   2025-10-14         → task doc 1  ← abc's oldest
    ObjectId(def)   2025-10-16         → task doc 8
    ObjectId(def)   2025-10-13         → task doc 6
    ObjectId(xyz)   2025-10-17         → task doc 9


WHY YOU DON'T NEED TWO SEPARATE INDEXES:
-----------------------------------------
You might think: "Should I create both of these?"
    db.tasks.create_index('user_id')                        # Simple index
    db.tasks.create_index([('user_id', 1), ('created_at', -1)])  # Compound index

Answer: NO! Just the compound index is enough!

The compound index can handle:
    1. Queries filtering by user_id only (uses index prefix)
    2. Queries filtering by user_id AND sorting by created_at (uses full index)

The simple index would be redundant (wastes space and slows down writes).

Exception: If you had MANY queries that only use user_id and NEVER sort by created_at,
you might benefit from a separate simple index. But in your app, stick with just the compound index.


============================================================================================================
                            WHEN TO CREATE INDEXES
============================================================================================================

Run index creation commands ONCE after your app starts for the first time.

Option 1: Run manually in MongoDB shell or Python console
Option 2: Add to your Flask app initialization (recommended):

try:
    # Create indexes
    db.users.create_index('username', unique=True)
    db.tasks.create_index([('user_id', 1), ('created_at', -1)])
    print("✅ Indexes created successfully")
except Exception as e:
    print(f"⚠️ Index creation: {e}")

MongoDB is smart: If indexes already exist, it won't create duplicates or throw errors.
The create_index() method is idempotent (safe to run multiple times).


CHECKING EXISTING INDEXES:
---------------------------
To see what indexes exist:
    db.users.list_indexes()
    db.tasks.list_indexes()

Every collection automatically has an index on '_id' field (primary key).


DROPPING INDEXES:
-----------------
To remove an index if you don't need it:
    db.tasks.drop_index('user_id_1')  # Drop by name
    db.tasks.drop_index([('user_id', 1)])  # Drop by specification


============================================================================================================
                            REAL-WORLD ANALOGY
============================================================================================================

Imagine a library with 100,000 books:

Without Index:
    - You want to find "Harry Potter"
    - You walk through EVERY aisle, checking EVERY book
    - Takes hours 😱

With Index (Card Catalog):
    - You look up "Harry Potter" in the card catalog (index)
    - Card says: "Aisle 23, Shelf 5, Position 12"
    - You walk directly there
    - Takes 2 minutes ⚡

The card catalog is the INDEX - it's a separate, sorted list that points you to the exact location!


============================================================================================================
                            SUMMARY FOR YOUR TODO APP
============================================================================================================

Create these indexes (run once):

# User collection - enforce unique usernames and fast login lookup
db.users.create_index('username', unique=True)

# Tasks collection - fast queries for "get user's tasks, sorted by newest first"
db.tasks.create_index([('user_id', 1), ('created_at', -1)])

That's it! These two indexes will make your app blazing fast, even with millions of users and tasks.

Remember:
    - Indexes make READS fast but WRITES slightly slower (acceptable trade-off)
    - Don't create too many indexes (each one takes space and slows writes)
    - Match index sort order (-1, 1) to your query patterns
    - Compound indexes can serve queries on their prefix fields
    - MongoDB maintains indexes automatically - you don't do anything special

Your app's query patterns are perfect for these indexes! 🚀
"""